<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –º–∞—Ä—à—Ä—É—Ç—É</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
    <div class="route-container">
        <div class="route-header">
            <h1><i class="fas fa-route"></i> <span id="title">–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –º–∞—Ä—à—Ä—É—Ç—É</span></h1>
            <p id="subtitle">–ü–ª–∞–Ω—É–≤–∞–Ω–Ω—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç—É –∑ –º–Ω–æ–∂–∏–Ω–Ω–∏–º–∏ —Ç–æ—á–∫–∞–º–∏</p>
        </div>

        <div class="route-content">
            <div class="form-grid">
                <div class="form-group">
                    <label class="form-label" id="start-point-label">üìç –ü–æ—á–∞—Ç–∫–æ–≤–∞ —Ç–æ—á–∫–∞</label>
                    <input type="text" class="form-control" id="pointA" placeholder="–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤">
                    <small style="color: var(--text-primary); margin-top: 5px; display: block; opacity: 0.7;">Start Point - S</small>
                </div>
                <div class="form-group">
                    <label class="form-label" id="final-point-label">üéØ –§—ñ–Ω–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞</label>
                    <input type="text" class="form-control" id="pointB" placeholder="–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –õ—å–≤—ñ–≤">
                    <small style="color: var(--text-primary); margin-top: 5px; display: block; opacity: 0.7;">Final Point - F</small>
                </div>
            </div>
            
            <div id="waypointsContainer"></div>
            
            <button class="btn-add-point" onclick="addWaypoint()" id="add-waypoint-btn">
                <i class="fas fa-plus"></i> <span id="add-waypoint-text">–î–æ–¥–∞—Ç–∏ –ø—Ä–æ–º—ñ–∂–Ω—É —Ç–æ—á–∫—É</span>
            </button>
            
            <div id="routeMap"></div>
            
            <div style="text-align: center; margin: 20px 0;">
                <button class="btn btn-primary" onclick="calculateRoutes()" id="calculate-btn">
                    <i class="fas fa-route"></i> <span id="calculate-text">–†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –≤—Å—ñ –º–∞—Ä—à—Ä—É—Ç–∏</span>
                </button>
            </div>
            
            <div id="routeResults" style="display: none;">
                <h5><i class="fas fa-road"></i> <span id="available-routes-text">–î–æ—Å—Ç—É–ø–Ω—ñ –≤–∞—Ä—ñ–∞–Ω—Ç–∏ –º–∞—Ä—à—Ä—É—Ç—ñ–≤:</span></h5>
                <div id="routeOptions" class="route-options"></div>
            </div>
            
            <div class="form-group" style="margin-top: 20px;">
                <label class="form-label" id="selected-distance-label">‚úÖ –û–±—Ä–∞–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É:</label>
                <div style="display: flex; gap: 10px;">
                    <input type="number" class="form-control" id="selectedDistance" readonly>
                    <button class="btn btn-primary" onclick="useDistance()" id="use-btn">
                        <i class="fas fa-check"></i> <span id="use-text">–í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let routeMap = null;
        let routeData = { routes: [], selectedRoute: null };
        let waypointCounter = 0;
        let routeLayers = [];
        let pointMarkers = {};
        let currentPointMode = null;
        
        // Auto-set language from parent
        document.addEventListener('DOMContentLoaded', function() {
            const savedLang = localStorage.getItem('language') || 'uk';
            setLanguage(savedLang);
            
            setTimeout(() => {
                try {
                    routeMap = L.map('routeMap').setView([49.0, 32.0], 6);
                    
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap contributors'
                    }).addTo(routeMap);
                    
                    routeMap.on('click', function(e) {
                        if (!document.getElementById('pointA').value) {
                            currentPointMode = 'start';
                            setPointOnMap(e.latlng.lat, e.latlng.lng);
                            return;
                        }
                        
                        if (!document.getElementById('pointB').value) {
                            currentPointMode = 'last';
                            setPointOnMap(e.latlng.lat, e.latlng.lng);
                            return;
                        }
                        
                        if (currentPointMode && typeof currentPointMode === 'number') {
                            setPointOnMap(e.latlng.lat, e.latlng.lng);
                        } else {
                            alert('–î–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø—Ä–æ–º—ñ–∂–Ω–æ—ó —Ç–æ—á–∫–∏ —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É "–î–æ–¥–∞—Ç–∏ –ø—Ä–æ–º—ñ–∂–Ω—É —Ç–æ—á–∫—É"');
                        }
                    });
                } catch (error) {
                    console.error('Map initialization error:', error);
                }
            }, 500);
        });
        
        const translations = {
            uk: {
                'title': '–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –º–∞—Ä—à—Ä—É—Ç—É',
                'subtitle': '–ü–ª–∞–Ω—É–≤–∞–Ω–Ω—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç—É –∑ –º–Ω–æ–∂–∏–Ω–Ω–∏–º–∏ —Ç–æ—á–∫–∞–º–∏',
                'start-point': '–ü–æ—á–∞—Ç–∫–æ–≤–∞ —Ç–æ—á–∫–∞',
                'final-point': '–§—ñ–Ω–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞',
                'add-waypoint': '–î–æ–¥–∞—Ç–∏ –ø—Ä–æ–º—ñ–∂–Ω—É —Ç–æ—á–∫—É',
                'calculate-routes': '–†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –≤—Å—ñ –º–∞—Ä—à—Ä—É—Ç–∏',
                'available-routes': '–î–æ—Å—Ç—É–ø–Ω—ñ –≤–∞—Ä—ñ–∞–Ω—Ç–∏ –º–∞—Ä—à—Ä—É—Ç—ñ–≤:',
                'selected-distance': '–û–±—Ä–∞–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É:',
                'use-distance': '–í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏',
                'waypoint': '–ü—Ä–æ–º—ñ–∂–Ω–∞ —Ç–æ—á–∫–∞',
                'start-placeholder': '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤',
                'final-placeholder': '–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –õ—å–≤—ñ–≤'
            },
            en: {
                'title': 'Route Calculator',
                'subtitle': 'Optimal route planning with multiple waypoints',
                'start-point': 'Start Point',
                'final-point': 'Final Point',
                'add-waypoint': 'Add Waypoint',
                'calculate-routes': 'Calculate All Routes',
                'available-routes': 'Available Route Options:',
                'selected-distance': 'Selected Distance for Calculation:',
                'use-distance': 'Use',
                'waypoint': 'Waypoint',
                'start-placeholder': 'e.g.: Kyiv',
                'final-placeholder': 'e.g.: Lviv'
            },
            fr: {
                'title': 'Calculateur d\'Itin√©raire',
                'subtitle': 'Planification d\'itin√©raire optimal avec plusieurs points',
                'start-point': 'Point de D√©part',
                'final-point': 'Point Final',
                'add-waypoint': 'Ajouter Point',
                'calculate-routes': 'Calculer Tous les Itin√©raires',
                'available-routes': 'Options d\'Itin√©raire Disponibles:',
                'selected-distance': 'Distance S√©lectionn√©e:',
                'use-distance': 'Utiliser',
                'waypoint': 'Point Interm√©diaire',
                'start-placeholder': 'ex: Kiev',
                'final-placeholder': 'ex: Lviv'
            }
        };
        
        function setLanguage(lang) {
            const translation = translations[lang];
            if (translation) {
                // Update main elements
                document.getElementById('title').textContent = translation['title'];
                document.getElementById('subtitle').textContent = translation['subtitle'];
                document.getElementById('start-point-label').innerHTML = `üìç ${translation['start-point']}`;
                document.getElementById('final-point-label').innerHTML = `üéØ ${translation['final-point']}`;
                document.getElementById('add-waypoint-text').textContent = translation['add-waypoint'];
                document.getElementById('calculate-text').textContent = translation['calculate-routes'];
                document.getElementById('available-routes-text').textContent = translation['available-routes'];
                document.getElementById('selected-distance-label').innerHTML = `‚úÖ ${translation['selected-distance']}`;
                document.getElementById('use-text').textContent = translation['use-distance'];
                
                // Update placeholders
                document.getElementById('pointA').placeholder = translation['start-placeholder'];
                document.getElementById('pointB').placeholder = translation['final-placeholder'];
            }
        }
        
        function setPointOnMap(lat, lng) {
            if (!currentPointMode) {
                const pointA = document.getElementById('pointA').value;
                const pointB = document.getElementById('pointB').value;
                
                if (!pointA) {
                    currentPointMode = 'start';
                } else if (!pointB) {
                    currentPointMode = 'last';
                }
            }
            
            if (currentPointMode) {
                let inputId, displayText, color, displayNumber;
                
                if (currentPointMode === 'start') {
                    inputId = 'pointA';
                    displayText = `–°—Ç–∞—Ä—Ç–æ–≤–∞ —Ç–æ—á–∫–∞ (${lat.toFixed(6)}, ${lng.toFixed(6)})`;
                    color = '#00ff00';
                    displayNumber = 'S';
                } else if (currentPointMode === 'last') {
                    inputId = 'pointB';
                    displayText = `–§—ñ–Ω–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞ (${lat.toFixed(6)}, ${lng.toFixed(6)})`;
                    color = '#ff0040';
                    displayNumber = 'F';
                } else {
                    inputId = `point${currentPointMode + 1}`;
                    displayText = `–ü—Ä–æ–º—ñ–∂–Ω–∞ —Ç–æ—á–∫–∞ ${currentPointMode} (${lat.toFixed(6)}, ${lng.toFixed(6)})`;
                    color = '#0066ff';
                    displayNumber = currentPointMode;
                }
                
                const input = document.getElementById(inputId);
                if (input) {
                    input.value = displayText;
                }
                
                const markerKey = currentPointMode === 'start' ? 'start' : currentPointMode === 'last' ? 'last' : currentPointMode;
                
                if (pointMarkers[markerKey]) {
                    routeMap.removeLayer(pointMarkers[markerKey]);
                }
                
                const marker = L.marker([lat, lng], {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background: ${color}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${displayNumber}</div>`,
                        iconSize: [30, 30]
                    })
                }).addTo(routeMap);
                
                pointMarkers[markerKey] = marker;
                
                currentPointMode = null;
                routeMap.getContainer().style.cursor = '';
            }
        }
        
        function addWaypoint() {
            if (waypointCounter > 0) {
                const prevPointInput = document.getElementById(`point${waypointCounter + 1}`);
                if (prevPointInput && !prevPointInput.value.trim()) {
                    alert(`–°–ø–æ—á–∞—Ç–∫—É –∑–∞–ø–æ–≤–Ω—ñ—Ç—å –ø—Ä–æ–º—ñ–∂–Ω—É —Ç–æ—á–∫—É ${waypointCounter}`);
                    return;
                }
            }
            
            waypointCounter++;
            const pointNumber = waypointCounter + 1;
            
            const waypointDiv = document.createElement('div');
            waypointDiv.className = 'waypoint-item';
            waypointDiv.id = `waypoint${pointNumber}`;
            const currentLang = localStorage.getItem('language') || 'uk';
            const waypointText = translations[currentLang]['waypoint'] || '–ü—Ä–æ–º—ñ–∂–Ω–∞ —Ç–æ—á–∫–∞';
            
            waypointDiv.innerHTML = `
                <div class="form-group" style="flex: 1; margin: 0;">
                    <label class="form-label">üìç ${waypointText} ${waypointCounter}</label>
                    <input type="text" class="form-control" id="point${pointNumber}" placeholder="${waypointText} ${waypointCounter}">
                </div>
                <button class="btn btn-secondary" onclick="removeWaypoint('${pointNumber}')" style="margin-top: 25px;">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            
            document.getElementById('waypointsContainer').appendChild(waypointDiv);
            
            currentPointMode = waypointCounter;
            if (routeMap) {
                routeMap.getContainer().style.cursor = 'crosshair';
            }
        }
        
        function removeWaypoint(pointNumber) {
            const waypoint = document.getElementById(`waypoint${pointNumber}`);
            if (waypoint) {
                waypoint.remove();
            }
            if (pointMarkers[pointNumber]) {
                routeMap.removeLayer(pointMarkers[pointNumber]);
                delete pointMarkers[pointNumber];
            }
        }
        
        async function calculateRoutes() {
            const pointA = document.getElementById('pointA').value.trim();
            const pointB = document.getElementById('pointB').value.trim();
            
            if (!pointA) {
                alert('–í–≤–µ–¥—ñ—Ç—å –ø–æ—á–∞—Ç–∫–æ–≤—É —Ç–æ—á–∫—É A');
                return;
            }
            
            const waypoints = [];
            
            const coordsA = await getCoordinates(pointA);
            if (!coordsA) {
                alert('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –ø–æ—á–∞—Ç–∫–æ–≤–æ—ó —Ç–æ—á–∫–∏');
                return;
            }
            waypoints.push(coordsA);
            
            for (let i = 1; i <= waypointCounter; i++) {
                const pointNum = i + 1;
                const input = document.getElementById(`point${pointNum}`);
                if (input && input.value.trim()) {
                    const coords = await getCoordinates(input.value.trim());
                    if (coords) {
                        waypoints.push(coords);
                    }
                }
            }
            
            if (pointB) {
                const coordsB = await getCoordinates(pointB);
                if (!coordsB) {
                    alert('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —Ñ—ñ–Ω–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏');
                    return;
                }
                waypoints.push(coordsB);
            }
            
            if (waypoints.length < 2) {
                alert('–î–æ–¥–∞–π—Ç–µ —â–æ–Ω–∞–π–º–µ–Ω—à 2 —Ç–æ—á–∫–∏');
                return;
            }
            
            await getMultipleRoutes(waypoints);
        }
        
        async function getCoordinates(location) {
            const coordMatch = location.match(/\(([^)]+)\)/);
            if (coordMatch) {
                const coords = coordMatch[1].split(',');
                if (coords.length === 2) {
                    return { lat: parseFloat(coords[0].trim()), lng: parseFloat(coords[1].trim()) };
                }
            }
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location + ' –£–∫—Ä–∞—ó–Ω–∞')}&countrycodes=ua&limit=1`);
                const results = await response.json();
                if (results.length > 0) {
                    return { lat: parseFloat(results[0].lat), lng: parseFloat(results[0].lon) };
                }
            } catch (error) {
                console.error('Geocoding error:', error);
            }
            return null;
        }
        
        async function getMultipleRoutes(waypoints) {
            if (waypoints.length < 2) return;
            
            const coords = waypoints.map(w => `${w.lng},${w.lat}`).join(';');
            routeData.routes = [];
            
            // Get OSRM routes
            try {
                const response = await fetch(`https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&alternatives=true&steps=false&geometries=geojson&continue_straight=false`);
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    data.routes.forEach((route, index) => {
                        routeData.routes.push({
                            id: `osrm_${index}`,
                            type: `–ú–∞—Ä—à—Ä—É—Ç ${index + 1}`,
                            distance: (route.distance / 1000).toFixed(1),
                            duration: Math.round(route.duration / 60),
                            source: 'OSRM',
                            geometry: route.geometry
                        });
                    });
                }
            } catch (error) {
                console.error('OSRM error:', error);
            }
            
            // Add straight line distance only if no OSRM routes
            if (routeData.routes.length === 0) {
                const straightDistance = calculateStraightDistance(waypoints);
                routeData.routes.push({
                    id: 'straight',
                    type: '–ü—Ä—è–º–∞ –ª—ñ–Ω—ñ—è',
                    distance: straightDistance.toFixed(1),
                    duration: Math.round(straightDistance * 1.2),
                    source: '–ì–µ–æ—Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫'
                });
            }
            
            drawRoutesOnMap(waypoints);
            displayRouteOptions();
        }
        
        function calculateStraightDistance(waypoints) {
            if (waypoints.length < 2) return 0;
            
            let totalDistance = 0;
            for (let i = 0; i < waypoints.length - 1; i++) {
                const R = 6371;
                const dLat = (waypoints[i + 1].lat - waypoints[i].lat) * Math.PI / 180;
                const dLng = (waypoints[i + 1].lng - waypoints[i].lng) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(waypoints[i].lat * Math.PI / 180) * Math.cos(waypoints[i + 1].lat * Math.PI / 180) * Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                totalDistance += R * c;
            }
            return totalDistance;
        }
        
        function drawRoutesOnMap(waypoints) {
            routeLayers.forEach(layer => routeMap.removeLayer(layer));
            routeLayers = [];
            Object.values(pointMarkers).forEach(marker => routeMap.removeLayer(marker));
            pointMarkers = {};
            
            const colors = ['#ff0000', '#0066ff', '#ff9900', '#9900ff', '#00ff00', '#ff6600', '#6600ff'];
            
            routeData.routes.forEach((route, index) => {
                const linePoints = waypoints.map(w => [w.lat, w.lng]);
                let routeLayer;
                const routeColor = colors[index] || '#666666';
                
                if (route.geometry) {
                    routeLayer = L.geoJSON(route.geometry, {
                        style: {
                            color: routeColor,
                            weight: 5,
                            opacity: 0.8
                        }
                    }).addTo(routeMap);
                } else {
                    const style = {
                        color: routeColor,
                        weight: route.id === 'straight' ? 3 : 4,
                        opacity: route.id === 'straight' ? 0.6 : 0.7
                    };
                    
                    if (route.id === 'straight') {
                        style.dashArray = '10, 5';
                    }
                    
                    routeLayer = L.polyline(linePoints, style).addTo(routeMap);
                }
                
                if (routeLayer) {
                    routeLayer.on('click', () => selectRoute(route.id));
                    routeLayers.push(routeLayer);
                }
            });
            
            waypoints.forEach((waypoint, index) => {
                const isFirst = index === 0;
                const isLast = index === waypoints.length - 1;
                const pointNumber = isFirst ? 'S' : isLast ? 'F' : (index);
                const color = isFirst ? '#00ff00' : isLast ? '#ff0040' : '#0066ff';
                
                const marker = L.marker([waypoint.lat, waypoint.lng], {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background: ${color}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${pointNumber}</div>`,
                        iconSize: [30, 30]
                    })
                }).addTo(routeMap);
                
                pointMarkers[index + 1] = marker;
            });
            
            if (waypoints.length > 0) {
                const group = new L.featureGroup([...routeLayers, ...Object.values(pointMarkers)]);
                routeMap.fitBounds(group.getBounds().pad(0.1));
            }
        }
        
        function displayRouteOptions() {
            const container = document.getElementById('routeOptions');
            const colors = ['#ff0040', '#00ff41', '#ff9900', '#0099ff', '#9900ff', '#666666', '#ff6600', '#6600ff'];
            
            if (routeData.routes.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">–ú–∞—Ä—à—Ä—É—Ç–∏ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ</div>';
                return;
            }
            
            container.innerHTML = routeData.routes.map((route, index) => {
                const routeColor = colors[index] || '#666666';
                
                return `
                <div class="route-option" onclick="selectRoute('${route.id}')" data-route="${route.id}">
                    <div class="route-info">
                        <div class="route-title">
                            ${route.type}

                        </div>
                        <div class="route-details">
                            <i class="fas fa-map"></i> ${route.source} ‚Ä¢ 
                            <i class="fas fa-clock"></i> ~${route.duration} —Ö–≤
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="background: ${routeColor}; width: 25px; height: 4px; border-radius: 2px; display: inline-block;"></span>
                        <div class="route-distance">${route.distance} –∫–º</div>
                    </div>
                </div>
                `;
            }).join('');
            
            document.getElementById('routeResults').style.display = 'block';
            
            // Auto-select first route for convenience
            if (routeData.routes.length > 0) {
                selectRoute(routeData.routes[0].id);
            }
        }
        
        function selectRoute(routeId) {
            document.querySelectorAll('.route-option').forEach(el => el.classList.remove('selected'));
            
            const selectedRoute = routeData.routes.find(r => r.id === routeId);
            if (selectedRoute) {
                const routeElement = document.querySelector(`[data-route="${routeId}"]`);
                if (routeElement) {
                    routeElement.classList.add('selected');
                }
                
                document.getElementById('selectedDistance').value = selectedRoute.distance;
                routeData.selectedRoute = selectedRoute;
            }
        }
        
        function useDistance() {
            const distance = document.getElementById('selectedDistance').value;
            if (distance && distance > 0) {
                // Send distance to parent window
                window.parent.postMessage({
                    type: 'routeDistance',
                    distance: distance
                }, '*');
            } else {
                alert('–û–±–µ—Ä—ñ—Ç—å –º–∞—Ä—à—Ä—É—Ç');
            }
        }
        

        
        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme || 'dark');
        }
        
        window.addEventListener('message', function(event) {
            if (event.data.type === 'themeChange') {
                applyTheme(event.data.theme);
            }
            if (event.data.type === 'setLanguage') {
                setLanguage(event.data.language);
            }
        });
    </script>
</body>
</html>