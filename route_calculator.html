<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –º–∞—Ä—à—Ä—É—Ç—É</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>

        

        
        .lang-btn {
            width: 40px;
            height: 40px;
            border: 2px solid var(--primary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(255, 0, 64, 0.2);
        }
        
        .lang-btn:hover {
            background: var(--primary);
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(255, 0, 64, 0.4);
        }
        

        .language-switcher {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 5px;
        }
        
        .lang-btn {
            width: 40px;
            height: 40px;
            border: 2px solid var(--primary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(255, 0, 64, 0.2);
        }
        
        .lang-btn:hover {
            background: var(--primary);
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(255, 0, 64, 0.4);
        }
        
        .top-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .control-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #ff0040;
            background: #000;
            color: #ff0040;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            font-family: 'Times New Roman', serif;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(255, 0, 64, 0.2);
        }
        
        .control-btn:hover {
            background: #ff0040;
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(255, 0, 64, 0.4);
        }
    </style>
</head>
<body>
    <div class="top-controls">
        <a href="index.html" class="control-btn" title="–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é">
            <i class="fas fa-home"></i>
        </a>
        <button class="control-btn" onclick="toggleLanguage()" title="–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É" id="langBtn">üá∫üá¶</button>
    </div>

    
    <div class="route-container">
        <div class="route-header">
            <h1><i class="fas fa-route"></i> <span id="title">–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –º–∞—Ä—à—Ä—É—Ç—É</span></h1>
            <p id="subtitle">–ü–ª–∞–Ω—É–≤–∞–Ω–Ω—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç—É –∑ –º–Ω–æ–∂–∏–Ω–Ω–∏–º–∏ —Ç–æ—á–∫–∞–º–∏</p>
        </div>

        <div class="route-content">
            <div class="form-grid">
                <div class="form-group">
                    <label class="form-label">üìç –ü–æ—á–∞—Ç–∫–æ–≤–∞ —Ç–æ—á–∫–∞</label>
                    <input type="text" class="form-control" id="pointA" placeholder="–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –ö–∏—ó–≤">
                    <small style="color: var(--text-primary); margin-top: 5px; display: block; opacity: 0.7;">Start Point - S</small>
                </div>
                <div class="form-group">
                    <label class="form-label">üéØ –§—ñ–Ω–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞</label>
                    <input type="text" class="form-control" id="pointB" placeholder="–ù–∞–ø—Ä–∏–∫–ª–∞–¥: –õ—å–≤—ñ–≤">
                    <small style="color: var(--text-primary); margin-top: 5px; display: block; opacity: 0.7;">Final Point - F</small>
                </div>
            </div>
            
            <div id="waypointsContainer"></div>
            
            <button class="btn-add-point" onclick="addWaypoint()">
                <i class="fas fa-plus"></i> –î–æ–¥–∞—Ç–∏ –ø—Ä–æ–º—ñ–∂–Ω—É —Ç–æ—á–∫—É
            </button>
            
            <div id="routeMap"></div>
            
            <div style="text-align: center; margin: 20px 0;">
                <button class="btn btn-primary" onclick="calculateRoutes()">
                    <i class="fas fa-route"></i> –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –≤—Å—ñ –º–∞—Ä—à—Ä—É—Ç–∏
                </button>
            </div>
            
            <div id="routeResults" style="display: none;">
                <h5><i class="fas fa-road"></i> –î–æ—Å—Ç—É–ø–Ω—ñ –≤–∞—Ä—ñ–∞–Ω—Ç–∏ –º–∞—Ä—à—Ä—É—Ç—ñ–≤:</h5>
                <div id="routeOptions" class="route-options"></div>
            </div>
            
            <div class="form-group" style="margin-top: 20px;">
                <label class="form-label">‚úÖ –û–±—Ä–∞–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É:</label>
                <div style="display: flex; gap: 10px;">
                    <input type="number" class="form-control" id="selectedDistance" readonly>
                    <button class="btn btn-primary" onclick="useDistance()">
                        <i class="fas fa-check"></i> –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let routeMap = null;
        let routeData = { routes: [], selectedRoute: null };
        let waypointCounter = 0;
        let routeLayers = [];
        let pointMarkers = {};
        let currentPointMode = null;
        
        function setPointOnMap(lat, lng) {
            if (!currentPointMode) {
                const pointA = document.getElementById('pointA').value;
                const pointB = document.getElementById('pointB').value;
                
                if (!pointA) {
                    currentPointMode = 'start';
                } else if (!pointB) {
                    currentPointMode = 'last';
                }
            }
            
            if (currentPointMode) {
                let inputId, displayText, color, displayNumber;
                
                if (currentPointMode === 'start') {
                    inputId = 'pointA';
                    displayText = `–°—Ç–∞—Ä—Ç–æ–≤–∞ —Ç–æ—á–∫–∞ (${lat.toFixed(6)}, ${lng.toFixed(6)})`;
                    color = '#00ff00';
                    displayNumber = 'S';
                } else if (currentPointMode === 'last') {
                    inputId = 'pointB';
                    displayText = `–§—ñ–Ω–∞–ª—å–Ω–∞ —Ç–æ—á–∫–∞ (${lat.toFixed(6)}, ${lng.toFixed(6)})`;
                    color = '#ff0040';
                    displayNumber = 'F';
                } else {
                    inputId = `point${currentPointMode + 1}`;
                    displayText = `–ü—Ä–æ–º—ñ–∂–Ω–∞ —Ç–æ—á–∫–∞ ${currentPointMode} (${lat.toFixed(6)}, ${lng.toFixed(6)})`;
                    color = '#0066ff';
                    displayNumber = currentPointMode;
                }
                
                const input = document.getElementById(inputId);
                if (input) {
                    input.value = displayText;
                }
                
                const markerKey = currentPointMode === 'start' ? 'start' : currentPointMode === 'last' ? 'last' : currentPointMode;
                
                if (pointMarkers[markerKey]) {
                    routeMap.removeLayer(pointMarkers[markerKey]);
                }
                
                const marker = L.marker([lat, lng], {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background: ${color}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${displayNumber}</div>`,
                        iconSize: [30, 30]
                    })
                }).addTo(routeMap);
                
                pointMarkers[markerKey] = marker;
                
                currentPointMode = null;
                routeMap.getContainer().style.cursor = '';
                

                const inputElement = document.getElementById(inputId);
                if (inputElement) {
                    inputElement.style.borderColor = 'var(--primary)';
                    setTimeout(() => {
                        inputElement.style.borderColor = '';
                    }, 1000);
                }
            }
        }
        
        const translations = {
            uk: {
                'title': '–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –º–∞—Ä—à—Ä—É—Ç—É',
                'subtitle': '–ü–ª–∞–Ω—É–≤–∞–Ω–Ω—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç—É –∑ –º–Ω–æ–∂–∏–Ω–Ω–∏–º–∏ —Ç–æ—á–∫–∞–º–∏'
            },
            en: {
                'title': 'Route Calculator',
                'subtitle': 'Optimal route planning with multiple waypoints'
            },
            fr: {
                'title': 'Calculateur d\'Itin√©raire',
                'subtitle': 'Planification d\'itin√©raire optimal avec plusieurs points'
            }
        };
        
        function setLanguage(lang) {
            const translation = translations[lang];
            if (translation) {
                for (const [key, value] of Object.entries(translation)) {
                    const element = document.getElementById(key);
                    if (element) {
                        element.textContent = value;
                    }
                }
            }
            localStorage.setItem('language', lang);
            updateLanguageButton(lang);
        }
        
        function toggleLanguage() {
            const currentLang = localStorage.getItem('language') || 'uk';
            const languages = ['uk', 'en', 'fr'];
            const currentIndex = languages.indexOf(currentLang);
            const nextIndex = (currentIndex + 1) % languages.length;
            setLanguage(languages[nextIndex]);
        }
        
        function updateLanguageButton(lang) {
            const flags = { uk: 'üá∫üá¶', en: 'üá∫üá∏', fr: 'üá´üá∑' };
            const btn = document.getElementById('langBtn');
            if (btn) btn.textContent = flags[lang] || flags.uk;
        }


        document.addEventListener('DOMContentLoaded', function() {
            const savedLang = localStorage.getItem('language') || 'uk';
            setLanguage(savedLang);
            updateLanguageButton(savedLang);
            
            // Remove existing map if any
            if (routeMap) {
                routeMap.remove();
                routeMap = null;
            }
            
            // Check if Leaflet is loaded
            if (typeof L === 'undefined') {
                console.error('Leaflet not loaded');
                document.getElementById('routeMap').innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-primary);">Leaflet –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ</div>';
                return;
            }
            
            setTimeout(() => {
                try {
                    routeMap = L.map('routeMap').setView([49.0, 32.0], 6);
                    
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap contributors'
                    }).addTo(routeMap);
                    
                    // Click on map to set points
                    routeMap.on('click', function(e) {
                        if (!document.getElementById('pointA').value) {
                            currentPointMode = 'start';
                            setPointOnMap(e.latlng.lat, e.latlng.lng);
                            return;
                        }
                        
                        if (!document.getElementById('pointB').value) {
                            currentPointMode = 'last';
                            setPointOnMap(e.latlng.lat, e.latlng.lng);
                            return;
                        }
                        
                        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î –∞–∫—Ç–∏–≤–Ω–∏–π —Ä–µ–∂–∏–º –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø—Ä–æ–º—ñ–∂–Ω–æ—ó —Ç–æ—á–∫–∏
                        if (currentPointMode && typeof currentPointMode === 'number') {
                            setPointOnMap(e.latlng.lat, e.latlng.lng);
                        } else {
                            alert('–î–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø—Ä–æ–º—ñ–∂–Ω–æ—ó —Ç–æ—á–∫–∏ —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É "–î–æ–¥–∞—Ç–∏ –ø—Ä–æ–º—ñ–∂–Ω—É —Ç–æ—á–∫—É"');
                        }
                    });
                    
                    console.log('Map initialized successfully');
                } catch (error) {
                    console.error('Map initialization error:', error);
                    document.getElementById('routeMap').innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-primary);">–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó –∫–∞—Ä—Ç–∏</div>';
                    return;
                }
            }, 500);
            
            // Click on map to set points
            routeMap.on('click', function(e) {
                // –Ø–∫—â–æ –Ω–µ–º–∞—î –ø–æ—á–∞—Ç–∫–æ–≤–æ—ó —Ç–æ—á–∫–∏ - –¥–æ–¥–∞—î–º–æ —ó—ó
                if (!document.getElementById('pointA').value) {
                    currentPointMode = 'start';
                    setPointOnMap(e.latlng.lat, e.latlng.lng);
                    return;
                }
                
                // –Ø–∫—â–æ —î –ø–æ—á–∞—Ç–∫–æ–≤–∞, –∞–ª–µ –Ω–µ–º–∞—î —Ñ—ñ–Ω–∞–ª—å–Ω–æ—ó - –¥–æ–¥–∞—î–º–æ —Ñ—ñ–Ω–∞–ª—å–Ω—É
                if (!document.getElementById('pointB').value) {
                    currentPointMode = 'last';
                    setPointOnMap(e.latlng.lat, e.latlng.lng);
                    return;
                }
                
                // –Ü–Ω–∞–∫—à–µ –Ω—ñ—á–æ–≥–æ –Ω–µ —Ä–æ–±–∏–º–æ - –ø–æ—Ç—Ä—ñ–±–Ω–æ —Å–ø–æ—á–∞—Ç–∫—É –¥–æ–¥–∞—Ç–∏ –ø–æ–ª–µ
                alert('–î–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è –ø—Ä–æ–º—ñ–∂–Ω–æ—ó —Ç–æ—á–∫–∏ —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É "–î–æ–¥–∞—Ç–∏ –ø–æ–ª–µ –¥–ª—è —Ç–æ—á–∫–∏"');
            });
            
                    // Add focus listeners
                    document.getElementById('pointA').addEventListener('focus', () => {
                        currentPointMode = 'start';
                        routeMap.getContainer().style.cursor = 'crosshair';
                    });
                    
                    document.getElementById('pointB').addEventListener('focus', () => {
                        currentPointMode = 'last';
                        routeMap.getContainer().style.cursor = 'crosshair';
                    });
                    
                    // –î–æ–¥–∞—î–º–æ blur –æ–±—Ä–æ–±–Ω–∏–∫–∏
                    document.getElementById('pointB').addEventListener('blur', () => {
                        setTimeout(() => {
                            if (currentPointMode === 'last') {
                                currentPointMode = null;
                                routeMap.getContainer().style.cursor = '';
                            }
                        }, 200);
                    });
            
            const savedTheme = localStorage.getItem('theme') || 'dark';
            applyTheme(savedTheme);
        });
        
        function addWaypoint() {
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –∑–∞–ø–æ–≤–Ω–µ–Ω–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—è —Ç–æ—á–∫–∞
            if (waypointCounter > 0) {
                const prevPointInput = document.getElementById(`point${waypointCounter + 1}`);
                if (prevPointInput && !prevPointInput.value.trim()) {
                    alert(`–°–ø–æ—á–∞—Ç–∫—É –∑–∞–ø–æ–≤–Ω—ñ—Ç—å –ø—Ä–æ–º—ñ–∂–Ω—É —Ç–æ—á–∫—É ${waypointCounter}`);
                    return;
                }
            }
            
            waypointCounter++;
            const pointNumber = waypointCounter + 1; // 2, 3, 4...
            
            const waypointDiv = document.createElement('div');
            waypointDiv.className = 'waypoint-item';
            waypointDiv.id = `waypoint${pointNumber}`;
            waypointDiv.innerHTML = `
                <div class="form-group" style="flex: 1; margin: 0;">
                    <label class="form-label">üìç –ü—Ä–æ–º—ñ–∂–Ω–∞ —Ç–æ—á–∫–∞ ${waypointCounter}</label>
                    <input type="text" class="form-control" id="point${pointNumber}" placeholder="–ü—Ä–æ–º—ñ–∂–Ω–∞ —Ç–æ—á–∫–∞ ${waypointCounter}">
                </div>
                <button class="btn btn-secondary" onclick="removeWaypoint('${pointNumber}')" style="margin-top: 25px;">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            
            document.getElementById('waypointsContainer').appendChild(waypointDiv);
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∞–∫—Ç–∏–≤—É—î–º–æ —Ä–µ–∂–∏–º –¥–æ–¥–∞–≤–∞–Ω–Ω—è —Ç–æ—á–∫–∏
            currentPointMode = waypointCounter;
            if (routeMap) {
                routeMap.getContainer().style.cursor = 'crosshair';
            }
            
            // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫–∏ –¥–ª—è –ø–æ–ª—è
            setTimeout(() => {
                const input = document.getElementById(`point${pointNumber}`);
                if (input) {
                    input.addEventListener('focus', () => {
                        currentPointMode = waypointCounter;
                        if (routeMap) {
                            routeMap.getContainer().style.cursor = 'crosshair';
                        }
                    });
                    
                    input.addEventListener('blur', () => {
                        setTimeout(() => {
                            if (currentPointMode === waypointCounter) {
                                currentPointMode = null;
                                if (routeMap) {
                                    routeMap.getContainer().style.cursor = '';
                                }
                            }
                        }, 200);
                    });
                }
            }, 100);
        }
        
        function addWaypointFromMap(lat, lng) {
            waypointCounter++;
            const pointNumber = waypointCounter + 1; // 2, 3, 4...
            
            const waypointDiv = document.createElement('div');
            waypointDiv.className = 'waypoint-item';
            waypointDiv.id = `waypoint${pointNumber}`;
            waypointDiv.innerHTML = `
                <div class="form-group" style="flex: 1; margin: 0;">
                    <label class="form-label">üìç –ü—Ä–æ–º—ñ–∂–Ω–∞ —Ç–æ—á–∫–∞ ${waypointCounter}</label>
                    <input type="text" class="form-control" id="point${pointNumber}" value="–¢–æ—á–∫–∞ ${waypointCounter} (${lat.toFixed(6)}, ${lng.toFixed(6)})" readonly>
                </div>
                <button class="btn btn-secondary" onclick="removeWaypoint('${pointNumber}')" style="margin-top: 25px;">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            
            document.getElementById('waypointsContainer').appendChild(waypointDiv);
        }
        
        function removeWaypoint(pointNumber) {
            const waypoint = document.getElementById(`waypoint${pointNumber}`);
            if (waypoint) {
                waypoint.remove();
            }
            if (pointMarkers[pointNumber]) {
                routeMap.removeLayer(pointMarkers[pointNumber]);
                delete pointMarkers[pointNumber];
            }
        }
        
        async function calculateRoutes() {
            const pointA = document.getElementById('pointA').value.trim();
            const pointB = document.getElementById('pointB').value.trim();
            
            if (!pointA) {
                alert('–í–≤–µ–¥—ñ—Ç—å –ø–æ—á–∞—Ç–∫–æ–≤—É —Ç–æ—á–∫—É A');
                return;
            }
            
            // Collect all waypoints
            const waypoints = [];
            
            // Add point A (start)
            const coordsA = await getCoordinates(pointA);
            if (!coordsA) {
                alert('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –ø–æ—á–∞—Ç–∫–æ–≤–æ—ó —Ç–æ—á–∫–∏');
                return;
            }
            waypoints.push(coordsA);
            
            // Add intermediate points
            for (let i = 1; i <= waypointCounter; i++) {
                const pointNum = i + 1; // point2, point3, etc.
                const input = document.getElementById(`point${pointNum}`);
                if (input && input.value.trim()) {
                    const coords = await getCoordinates(input.value.trim());
                    if (coords) {
                        waypoints.push(coords);
                    }
                }
            }
            
            // Add point B (final) if exists
            if (pointB) {
                const coordsB = await getCoordinates(pointB);
                if (!coordsB) {
                    alert('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —Ñ—ñ–Ω–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏');
                    return;
                }
                waypoints.push(coordsB);
            }
            
            if (waypoints.length < 2) {
                alert('–î–æ–¥–∞–π—Ç–µ —â–æ–Ω–∞–π–º–µ–Ω—à 2 —Ç–æ—á–∫–∏');
                return;
            }
            
            await getMultipleRoutes(waypoints);
        }
        
        async function getCoordinates(location) {
            // Check if location contains coordinates
            const coordMatch = location.match(/\(([^)]+)\)/);
            if (coordMatch) {
                const coords = coordMatch[1].split(',');
                if (coords.length === 2) {
                    return { lat: parseFloat(coords[0].trim()), lng: parseFloat(coords[1].trim()) };
                }
            }
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location + ' –£–∫—Ä–∞—ó–Ω–∞')}&countrycodes=ua&limit=1`);
                const results = await response.json();
                if (results.length > 0) {
                    return { lat: parseFloat(results[0].lat), lng: parseFloat(results[0].lon) };
                }
            } catch (error) {
                console.error('Geocoding error:', error);
            }
            return null;
        }
        
        async function getMultipleRoutes(waypoints) {
            if (waypoints.length < 2) return;
            
            const coords = waypoints.map(w => `${w.lng},${w.lat}`).join(';');
            routeData.routes = [];
            
            // Get routes from OSRM
            try {
                const response = await fetch(`https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&alternatives=true&steps=false&geometries=geojson`);
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    data.routes.forEach((route, index) => {
                        let routeType = '–ù–∞–π–∫–æ—Ä–æ—Ç—à–∏–π –º–∞—Ä—à—Ä—É—Ç';
                        if (index === 1) routeType = '–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç';
                        if (index === 2) routeType = '–û–±—ñ–∑–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç';
                        
                        routeData.routes.push({
                            id: `route_${index}`,
                            type: routeType,
                            distance: (route.distance / 1000).toFixed(1),
                            duration: Math.round(route.duration / 60),
                            source: 'OSRM –ù–∞–≤—ñ–≥–∞—Ç–æ—Ä',
                            geometry: route.geometry
                        });
                    });
                }
            } catch (error) {
                console.error('OSRM error:', error);
            }
            
            const straightDistance = calculateStraightDistance(waypoints);
            
            // –û—Ç—Ä–∏–º—É—î–º–æ —Ä–µ–∞–ª—å–Ω—ñ –º–∞—Ä—à—Ä—É—Ç–∏ —á–µ—Ä–µ–∑ —Ä—ñ–∑–Ω—ñ API
            const additionalRoutes = [];
            
            // –î–æ–¥–∞—î–º–æ –ø—Ä—è–º—É –ª—ñ–Ω—ñ—é –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è
            additionalRoutes.push({
                id: 'straight',
                type: '–ü—Ä—è–º–∞ –ª—ñ–Ω—ñ—è (–º—ñ–Ω—ñ–º–∞–ª—å–Ω–∞)',
                distance: straightDistance.toFixed(1),
                duration: Math.round(straightDistance * 1.2),
                source: '–ì–µ–æ—Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫'
            });
            
            // –û—Ç—Ä–∏–º—É—î–º–æ —Ä–µ–∞–ª—å–Ω—ñ –º–∞—Ä—à—Ä—É—Ç–∏ —á–µ—Ä–µ–∑ GraphHopper API
            try {
                const graphHopperUrl = `https://graphhopper.com/api/1/route?point=${coordsA.lat},${coordsA.lng}&point=${coordsB.lat},${coordsB.lng}&vehicle=car&locale=uk&calc_points=false&key=`;
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ø—É–±–ª—ñ—á–Ω–∏–π –¥–µ–º–æ –∫–ª—é—á –∞–±–æ –±–µ–∑ –∫–ª—é—á–∞ –¥–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è
                const ghResponse = await fetch(`https://graphhopper.com/api/1/route?point=${coordsA.lat},${coordsA.lng}&point=${coordsB.lat},${coordsB.lng}&vehicle=car&locale=uk&calc_points=false`);
                if (ghResponse.ok) {
                    const ghData = await ghResponse.json();
                    if (ghData.paths && ghData.paths.length > 0) {
                        ghData.paths.forEach((path, index) => {
                            additionalRoutes.push({
                                id: `graphhopper_${index}`,
                                type: index === 0 ? '–ù–∞–π–∫—Ä–∞—â–∏–π –º–∞—Ä—à—Ä—É—Ç' : `–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ ${index}`,
                                distance: (path.distance / 1000).toFixed(1),
                                duration: Math.round(path.time / 60000),
                                source: 'GraphHopper'
                            });
                        });
                    }
                }
            } catch (error) {
                console.log('GraphHopper API –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π');
            }
            
            // –û—Ç—Ä–∏–º—É—î–º–æ –º–∞—Ä—à—Ä—É—Ç–∏ —á–µ—Ä–µ–∑ MapBox API (—è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω–∏–π)
            try {
                const mapboxUrl = `https://api.mapbox.com/directions/v5/mapbox/driving/${coordsA.lng},${coordsA.lat};${coordsB.lng},${coordsB.lat}?alternatives=true&geometries=geojson&access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw`;
                const mbResponse = await fetch(mapboxUrl);
                if (mbResponse.ok) {
                    const mbData = await mbResponse.json();
                    if (mbData.routes && mbData.routes.length > 0) {
                        mbData.routes.forEach((route, index) => {
                            additionalRoutes.push({
                                id: `mapbox_${index}`,
                                type: index === 0 ? '–®–≤–∏–¥–∫–∏–π –º–∞—Ä—à—Ä—É—Ç' : `MapBox ${index + 1}`,
                                distance: (route.distance / 1000).toFixed(1),
                                duration: Math.round(route.duration / 60),
                                source: 'MapBox'
                            });
                        });
                    }
                }
            } catch (error) {
                console.log('MapBox API –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π');
            }
            
            routeData.routes.push(...additionalRoutes);
            
            console.log('Total routes found:', routeData.routes.length);
            routeData.routes.forEach((route, i) => console.log(`Route ${i}:`, route.type, route.distance + 'km'));
            
            drawRoutesOnMap(waypoints);
            displayRouteOptions();
        }
        
        function calculateStraightDistance(waypoints) {
            if (waypoints.length < 2) return 0;
            
            let totalDistance = 0;
            for (let i = 0; i < waypoints.length - 1; i++) {
                const R = 6371;
                const dLat = (waypoints[i + 1].lat - waypoints[i].lat) * Math.PI / 180;
                const dLng = (waypoints[i + 1].lng - waypoints[i].lng) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(waypoints[i].lat * Math.PI / 180) * Math.cos(waypoints[i + 1].lat * Math.PI / 180) * Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                totalDistance += R * c;
            }
            return totalDistance;
        }
        
        function drawRoutesOnMap(waypoints) {
            // Clear existing layers
            routeLayers.forEach(layer => routeMap.removeLayer(layer));
            routeLayers = [];
            Object.values(pointMarkers).forEach(marker => routeMap.removeLayer(marker));
            pointMarkers = {};
            
            const colors = ['#ff0000', '#0066ff', '#ff9900', '#9900ff', '#00ff00', '#ff6600', '#6600ff'];
            
            // Draw routes
            routeData.routes.forEach((route, index) => {
                const linePoints = waypoints.map(w => [w.lat, w.lng]);
                let routeLayer;
                const routeColor = colors[index] || '#666666';
                
                if (route.geometry) {
                    // OSRM routes with real geometry
                    routeLayer = L.geoJSON(route.geometry, {
                        style: {
                            color: routeColor,
                            weight: 5,
                            opacity: 0.8
                        }
                    }).addTo(routeMap);
                } else {
                    // Other routes - draw straight lines with different styles
                    const style = {
                        color: routeColor,
                        weight: route.id === 'straight' ? 3 : 4,
                        opacity: route.id === 'straight' ? 0.6 : 0.7
                    };
                    
                    if (route.id === 'straight') {
                        style.dashArray = '10, 5';
                    } else if (route.id === 'google') {
                        style.dashArray = '15, 10';
                    } else if (route.id === 'waze') {
                        style.dashArray = '5, 5';
                    }
                    
                    routeLayer = L.polyline(linePoints, style).addTo(routeMap);
                }
                
                if (routeLayer) {
                    routeLayer.on('click', () => selectRoute(route.id));
                    routeLayers.push(routeLayer);
                }
            });
            
            // Add waypoint markers with numbers
            waypoints.forEach((waypoint, index) => {
                const isFirst = index === 0;
                const isLast = index === waypoints.length - 1;
                const pointNumber = isFirst ? 'S' : isLast ? 'F' : (index);
                const color = isFirst ? '#00ff00' : isLast ? '#ff0040' : '#0066ff';
                
                const marker = L.marker([waypoint.lat, waypoint.lng], {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background: ${color}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${pointNumber}</div>`,
                        iconSize: [30, 30]
                    })
                }).addTo(routeMap);
                
                pointMarkers[index + 1] = marker;
            });
            
            // Fit map to show all points
            if (waypoints.length > 0) {
                const group = new L.featureGroup([...routeLayers, ...Object.values(pointMarkers)]);
                routeMap.fitBounds(group.getBounds().pad(0.1));
            }
        }
        
        function displayRouteOptions() {
            const container = document.getElementById('routeOptions');
            const colors = ['#ff0040', '#00ff41', '#ff9900', '#0099ff', '#9900ff', '#666666', '#ff6600', '#6600ff'];
            
            if (routeData.routes.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">–ú–∞—Ä—à—Ä—É—Ç–∏ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ</div>';
                return;
            }
            
            container.innerHTML = routeData.routes.map((route, index) => {
                const routeColor = colors[index] || '#666666';
                
                return `
                <div class="route-option" onclick="selectRoute('${route.id}')" data-route="${route.id}">
                    <div class="route-info">
                        <div class="route-title">
                            ${route.type}
                            ${index === 0 ? '<span class="route-badge">–†–ï–ö–û–ú–ï–ù–î–û–í–ê–ù–û</span>' : ''}
                        </div>
                        <div class="route-details">
                            <i class="fas fa-map"></i> ${route.source} ‚Ä¢ 
                            <i class="fas fa-clock"></i> ~${route.duration} —Ö–≤
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="background: ${routeColor}; width: 25px; height: 4px; border-radius: 2px; display: inline-block;"></span>
                        <div class="route-distance">${route.distance} –∫–º</div>
                    </div>
                </div>
                `;
            }).join('');
            
            document.getElementById('routeResults').style.display = 'block';
            
            if (routeData.routes.length > 0) {
                selectRoute(routeData.routes[0].id);
            }
        }
        
        function selectRoute(routeId) {
            document.querySelectorAll('.route-option').forEach(el => el.classList.remove('selected'));
            
            const selectedRoute = routeData.routes.find(r => r.id === routeId);
            if (selectedRoute) {
                const routeElement = document.querySelector(`[data-route="${routeId}"]`);
                if (routeElement) {
                    routeElement.classList.add('selected');
                }
                
                document.getElementById('selectedDistance').value = selectedRoute.distance;
                routeData.selectedRoute = selectedRoute;
                
                // –ü–æ–∫–∞–∑—É—î–º–æ —Ç—ñ–ª—å–∫–∏ –æ–±—Ä–∞–Ω–∏–π –º–∞—Ä—à—Ä—É—Ç
                showOnlySelectedRoute(routeId);
            }
        }
        
        function showOnlySelectedRoute(routeId) {
            const selectedIndex = routeData.routes.findIndex(r => r.id === routeId);
            
            routeLayers.forEach((layer, index) => {
                try {
                    if (index === selectedIndex) {
                        if (layer.setStyle) {
                            layer.setStyle({ opacity: 0.8, weight: 6 });
                        } else if (layer.eachLayer) {
                            layer.eachLayer(l => l.setStyle({ opacity: 0.8, weight: 6 }));
                        }
                    } else {
                        if (layer.setStyle) {
                            layer.setStyle({ opacity: 0.2, weight: 2 });
                        } else if (layer.eachLayer) {
                            layer.eachLayer(l => l.setStyle({ opacity: 0.2, weight: 2 }));
                        }
                    }
                } catch (e) {
                    console.log('Error setting style for layer:', e);
                }
            });
        }
        
        function useDistance() {
            if (routeData.selectedRoute) {
                // Send distance to parent window
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage({
                        type: 'routeDistance',
                        distance: routeData.selectedRoute.distance
                    }, '*');
                    
                    // Close the modal
                    setTimeout(() => {
                        if (window.parent.closeRouteModal) {
                            window.parent.closeRouteModal();
                        }
                    }, 200);
                } else {
                    // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –º–µ–Ω—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
                    document.getElementById('routeResults').style.display = 'none';
                    alert(`–û–±—Ä–∞–Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å: ${routeData.selectedRoute.distance} –∫–º`);
                }
            } else {
                alert('–û–±–µ—Ä—ñ—Ç—å –º–∞—Ä—à—Ä—É—Ç');
            }
        }
        
        // Theme handling
        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme || 'dark');
        }
        
        window.addEventListener('message', function(event) {
            if (event.data.type === 'themeChange') {
                applyTheme(event.data.theme);
            }
        });
        
        // Listen for theme changes from parent window
        if (window.parent !== window) {
            window.parent.addEventListener('message', function(event) {
                if (event.data.type === 'themeChange') {
                    applyTheme(event.data.theme);
                }
            });
        }
    </script>
</body>
</html>